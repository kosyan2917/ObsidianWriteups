Уязвимость в сервере next.js версии меньше 14.1.1. Позволяет делать запросы от имени сервера next js, в основном используется для [[SSRF]]. 
Вот описание от друга-гпт:

## Что случилось?

CVE-2024-34351 — это уязвимость типа **Server-Side Request Forgery (SSRF)** в механизме Server Actions фреймворка Next.js. При определённых условиях злоумышленник может подменить заголовок `Host` и тем самым заставить сервер делать произвольные запросы, маскируя их как отправленные самим приложением Next.js [CVE Mitre](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-34351&utm_source=chatgpt.com).

## Условия эксплуатации

Для успешной атаки должны быть одновременно выполнены три условия:

1. Next.js запущен в **self-hosted** режиме (т.е. не на Vercel, а на собственном сервере).
    
2. Приложение использует **Server Actions**.
    
3. В Server Action выполняется **редирект** на относительный путь, начинающийся с `/`.  
    При этом, подменив `Host`, злоумышленник может направить сервер на внутренний или внешний ресурс по своему выбору [NVD](https://nvd.nist.gov/view/vuln/detail?vulnId=CVE-2024-34351).
    

## Воздействие

- **Чтение ответов**. Атакующий получает полный HTTP-ответ от целевого ресурса.
    
- **Доступ к внутренним сервисам**. Поскольку запросы исходят изнутри сети приложения, есть риск обращения к метадате облачных сервисов или к приватным API.
    
- **Повышение привилегий**. Доступ к внутренним эндпоинтам может привести к раскрытию конфиденциальных данных или дальнейшим атакам на инфраструктуру [assetnote.io](https://www.assetnote.io/resources/research/advisory-next-js-ssrf-cve-2024-34351/?utm_source=chatgpt.com).
    

## Затронутые версии

- Все версии Next.js начиная с **13.4.0** и до **14.1.0** (включительно) уязвимы.
    
- Уязвимость устранена в **Next.js 14.1.1**

Вот как он описывает принцип ее работы:

Уязвимость CVE-2024-34351 срабатывает из-за сочетания трёх факторов в механизме Server Actions Next.js:

1. **Доверие к заголовку `Host`**  
    В self-hosted установках Next.js входящий HTTP-сервер (на базе Node.js) использует клиентский заголовок `Host` для построения URL при дальнейших внутренних запросах. Если злоумышленник присылает запрос с поддельным `Host`, фреймворк будет считать, что это именно тот хост, к которому ему нужно обращаться [assetnote.io](https://www.assetnote.io/resources/research/advisory-next-js-ssrf-cve-2024-34351/?utm_source=chatgpt.com).
    
2. **Использование встроенного `fetch` для редиректов**  
    Server Actions в Next.js по умолчанию при выполнении редиректа (например, через `redirect()` или возвращая ответ с кодом 3xx) передают управление встроенному polyfill-у `fetch`. Этот `fetch` автоматически следует за любыми редиректами, в том числе и по относительным путям [GitHub](https://github.com/advisories/GHSA-fr5h-rqp8-mj6g?utm_source=chatgpt.com).
    
3. **Разрешение относительных URL на основе `Host`**  
    Когда сервер возвращает ответ с `Location: /some/path`, встроенный `fetch` вычисляет конечный URL, объединяя базовый URL исходного запроса (включающий поддельный `Host`) и это относительное значение. В итоге `fetch` уходит не к законному `next.example.com`, а к любому хосту, который указал злоумышленник [NVD](https://nvd.nist.gov/vuln/detail/CVE-2024-34351?utm_source=chatgpt.com).
    
4. **Итоговая цепочка SSRF**
    
    1. Атакующий отправляет первый запрос на Server Action с заголовком `Host: attacker.local`.
        
    2. Server Action выдаёт редирект на относительный путь `/`.
        
    3. Встроенный `fetch` резолвит URL как `http://attacker.local/` и выполняет к нему запрос, возвращая полный HTTP-ответ назад атакующему.
        

Таким образом, Next.js сам подставляет подконтрольный клиенту `Host` при следовании за относительными редиректами, что и позволяет выполнить Server-Side Request Forgery.
Next.js внутри механизма Server Actions жёстко проверяет, чтобы запрос на выполнение действия приходил «с того же происхождения» (same-origin). Для этого он сравнивает:

1. **Host** — берётся из HTTP-заголовка `Host`
    
2. **Origin** — берётся из HTTP-заголовка `Origin`
    

Если эти два значения не совпадают, Next.js считает запрос потенциально CSRF-атакой и **прерывает** выполнение Server Action, бросая ошибку вида

`Invalid Server Actions request.`

— и внутренний `fetch` на `redirect()` не произойдёт [GitHub](https://github.com/vercel/next.js/discussions/65050).

---

### Как это выглядит в коде

В функции обработки редиректа (`createRedirectRenderResult`) Next.js делает примерно так:

```js

const host = req.headers['host'] const originDomain = new URL(req.headers['origin']).hostname  if (host !== originDomain && !isAllowedExtraOrigin(originDomain)) {   // Хост и Origin не совпадают → считаем это CSRF-атакой   
throw new Error('Invalid Server Actions request.') 
} 
…
const fetchUrl = new URL(`${proto}://${host}${redirectUrl}`) await fetch(fetchUrl, …)
```

По умолчанию `allowedOrigins` не задан, и сравнивается только строгое совпадение Host == Origin [Next.js by Vercel - The React Framework](https://nextjs.org/docs/app/api-reference/config/next-config-js/serverActions).


---

### Зачем в PoC менять одновременно и Host, и Origin

- В PoC мы подменяем `Host: attacker.example.com`, чтобы Next.js собрал `fetchUrl` на наш сервер злоумышленника.
    
- Но если при этом оставить `Origin: http://localhost:3000`, то Next.js увидит **несовпадение**:
    
    
    `host: attacker.example.com origin: localhost:3000`
    
    — и **откажется** выполнять Server Action (SSRF не сработает).
    

Поэтому в PoC заголовок `Origin` тоже подставляют на `http://attacker.example.com`, чтобы Next.js посчитал запрос «с того же происхождения» и разрешил пройти внутрь логики редиректа → внутреннего `fetch` к attacker-server